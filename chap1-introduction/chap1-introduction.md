## 开篇导读

### 简介

>本章内容：
>
>- 设计生产系统时需考量的关键取舍
>- 选择单元测试 vs 集成测试的结果
>- 不存在“一招鲜，吃遍天”的代码与架构设计模式



无论是设计程序，还是应用程序接口抑或是系统架构，我们都需要做各种各样的决定。这些决定会影响程序的可维护性、性能、可扩展性，产生无数潜在的后果。选定某个技术方向，另一个方向的发展就会到一定限制，这种的事儿在软件研发中屡见不鲜。系统存续的时间越长，修正之前的决定，改变系统的设计越困难。本书会花费大量笔墨讨论做程序设计取舍时，如何在两个或者多个技术方案间进行选择。无论你的决定是什么，选择技术方案时清楚地了解其优缺利弊，作到"胸中有丘壑"很重要。



研发团队往往需要结合项目背景，上市时间，服务等级协议（SLA）以及其它相关因素，综合考量，才能做出一个艰难的决定。我们会毫无保留地向您展示设计这些软件系统时做的那些取舍，并与其它可选方案进行比较。希望读完本书，你会开始关注日常每天都在做的那些设计抉择。关注这些，尤其是熟稔每种选择的优缺点，可以帮助您做出清晰的抉择。



本书开篇第一部分着重讨论每位软件工程师在做`API`设计和编码时都应考虑的底层设计决定。接着讨论系统设计中更宏观的部分——架构及各组件间的数据流。讨论也会涉及采用分布式系统架构时需注意的取舍。



接下来一节我们介绍本书分析取舍所采用的方法。首先，我们着重讨论每位软件工程师都得做的判断：如何在单元测试、集成测试、端到端测试、抑或是其他类型测试之间进行平衡。实际项目中，我们的常态是研发团队要在有限的开发周期内发布软件创造价值。因此，我们需要决定在哪种测试中投入更多的时间，单元测试、集成测试、端到端测试或者其它类型的测试？我们会逐一分析每种测试类型能带来的利与弊。



接着，我们介绍久经考验的单例模式，剖析为什么上下文差异会导致该设计模式的可用性发生变化。我们会结合一个单线程和一个多线程实例对这一观点进行阐述。最后，我们会从宏观角度分析采用微服务与单体模式的利与弊。



注意，描述软件架构时，简单粗暴地用纯微服务（**only micro-service**)或者纯单体模式（**only monolithic**)都是不确切的。我们经常在实际软件项目中看到混合模式的架构：有些功能以服务的方式实现，另一些部分则以单体系统的方式存在。譬如，对某个遗留系统，它可能整体而言是单体形态，少部分功切换到了微服务架构。此外，全新项目初始时只是一个应用，如果花费大量的代价将其微服务化，往往是得不偿失的。即便你采用混合架构，也需要根据项目实际情况，选择性地运用这些原则。



我们会用统一的方式介绍每一章的内容：首先是某个特定背景下的难题是如何解决的，接着分析其它可选的解决方案。最后，补充当时做决策的上下文及最终的选择。我们会分析每种解决方案在特定上下文中的利与弊。接下来的章节会围绕这些权衡做更深入的探讨。



#### 1.1 决定的后果与模式

本书的初衷是帮大家了解程序设计时应考虑的取舍以及经验教训。谈到设计选型取舍，我有一个假设前提，即你所编写的代码已经足够健壮。优秀的代码质量是软件大厦的基础，这之后你才需要考虑架构演进的方向。



为了帮你了解本书各章通用的内容组织形式，我们首先以两个群众基础深厚的取舍为例，分别是：集成测试和单元测试，它们可能是最立竿见影的软件质量保障实践，你的代码中很可能也已经用到了它们。



最终的目标是单元测试和集成测试可以覆盖所有的代码路径。然而，这很难在实践中达成。因为项目周期是有限的，你没有那么多的时间来完成编码并进行充分的测试。因此，投资多少资源与时间到单元测试与集成测试上就变成了每个人都需要面对的问题。

##### 1.1.1 单元测试

编写测试时，你需要决定测试哪部份代码。譬如，你需要对某个简单的组件`SystemComponent`进行单元测试，它只提供了一个`public`类型的接口。其他所有的方法都是客户端无法直接访问的私有类型。该场景的代码片段如下。

**代码清单1.1 组件单元测试**

```java
public class SystemComponent {
    public int publicApiMethod() {
        return privateApiMethod();
    }
    private int privateApiMethod() {
        return complexCalculations();
    }
    private int complexCalculations(){
        // come complex logic
        return 0;
    }
}
```

这时你需要判断，要不要为`complexCalculations()`添加单元测试，是否继续保持该方法的私有成员属性。这类单元测试属于黑盒测试，只能覆盖`public`类型的API。通常，单元测试做到这种程度就已经足够。然而，极端的情况下，譬如该私有方法的逻辑特别复杂，为其添加单元测试也是物有所值的。为了做到这一点，你得降低`complexCalculation()`的访问控制。下面的代码片段展示了对应的修改。

**代码清单1.2 通过公有访问方式进行单元测试**

```java
@VisibleForTesting
public int complexCalculations() {
    // Some complex logic
    return 0;
}
```

修改方法的可见性，将其由`private`变为`public`之后，你可以为这部分之前访问级别为`private`的API编写单元测试。由于`public`方法对所有API客户端都可见，你不得不面对客户端可以直接调用该方法的窘境。你可能会说，上述代码清单中不是还有这个`@VisiableForTesting`注解么？实际情况是，这个注解只能起到"提示信息"的效果，无法强制限定调用方不使用你`API`中的公有方法。如果调用方没有留意这个注解，他们可能忽略这一点。



本节提到的两种单元测试方法并无高低优劣之分。后一种方式提供了更高的灵活性，然而，随之而来的是维护代价的增加。你可以在这二者间取一个折衷方案。譬如，将代码的包标记为`private`类型。这样一来，由于测试代码与产品代码在同一个包内，你可以直接在测试代码中调用这些方法，不再需要将方法修改成`public`了。



##### 1.1.2 单元测试与集成测试的比例

计划测试任务时，你需要考虑对你的系统而言，应该按怎样的比例分配集成测试与单元测试。通常情况下，选定一个方案会直接影响另一个的结果。此外，这些局限也受该研发项目开始的时机影响。



大多数时候我们开发功能的时间都捉襟见肘，是否要投入更多的时间在功能测试或者集成测试上需要慎重的考虑。现实场景中，我们应该充分结合单元测试和集成测试的优势，最大程度地发挥其效能，这也是为什么我们需要思考该按怎样的比例分配单元测试和集成测试。



这两种测试方法都是双刃剑，各有其利也有其弊，是你编码时不得不做的利弊权衡。单元测试的优势是速度更快，反馈时间更短，因此调试流程通常也更快。

**图1.2 集成测试 vs. 单元测试 vs. 端到端测试**

![image-20220512111738870](./Software-Mistakes-and-Tradeoffs-1.2.png)



由于单元测试仅在单一组件中隔离运行，无法提供系统中其它组件的信息，也无法验证该组件如何与其它组件进行交互。集成测试的重要性此时就凸显了，它可以同时测试多个组件，验证组件之间的交互效果。不过，集成测试通常不会跨多个服务或者微服务去验证某个业务功能。最后我们要介绍的是端到端测试，这种测试可以对系统进行完整的验证，由于我们需要串联起整个系统，它可能包含若干个微服务、多个数据库、消息队列等等，测试涉及的组件数目是及其庞大的。



我们要考虑的另一个纬度是创建测试所需的时间（资源）。开发单元测试相对而言比较容易，我们只需花费比较少的时间就能创建大量的单元测试用例。创建集成测试往往需要更多的时间。最消耗资源的是端到端测试，创建端到端测试的基础设施需要预备大量的投入。   



实际项目中，我们的资金和时间资源往往捉襟见肘，虽然我们秉持尽最大可能提升软件质量的愿望，也要考虑方方面面的限制。用测试覆盖代码变更可以帮我们发布更高质量的软件，减少缺陷发版遗漏；长远而言，还可以提升软件的可维护性。资源有限的情况下，我们不得不思考，该选择做什么类型的测试，以及做到什么程度。我们需要在单元测试、集成测试、端到端测试之间寻找平衡点。多维度分析特定类型测试的优势与不足，帮助我们做出更合理的判断。



有一点，需要特别强调，也特别重要，那就是添加测试会拉长开发的时间。我们希望做的测试越全面，花费的时间就越多。如果不为这些测试任务分配时间，只是死板地限定项目交付日期，很难开展有效的端到端测试工作。因此，计划为产品添加新功能时，我们也需要考虑添加对应的测试任务，而不要奢望以事后来补的方式解决问题。



#### 1.2 设计模式及其失效分析

我们熟知的`建造者模式(Builder)`、`装饰器模式(Decorator)`、`原型模式(Prototype)`以及许多其他设计模式诞生的时间都不短。这些设计模式为解决典型的软件设计问题提供了久经考验的生产级解决方案。我强烈建议熟练掌握这些设计模式并在你的代码中使用它们。使用设计模式，代码的可维护性，可扩展性都会更好，也更优雅（关于设计模式的更多内容可以参考Erich Gamma等人合著的经典书籍《设计模式：可复用面向对象软件的基础》）。另一方面，使用设计模式时，你应该心怀敬畏，因为设计模式的实现对上下文有非常大的依赖。正如本书开篇所述，我们希望帮助您了解软件软件设计中的抉择取舍及其影响是什么。

我会以单例模式（https://refactoring.guru/design-patterns/singleton）为例进行介绍，帮助大家从代码层面理解这些取舍。引入单例模式的目的是提供一种所有组件共享通用状态的方式。单例是贯穿你应用整个生命周期的单一实例，被其他的类所引用。创建单例非常简单，你可以通过创建一个私有构造器来避免创建新的实例，代码实现如下所示：

> 代码清单 1.3 创建一个单例

```java 
public class Singleton {
  private static Singleton instance;
  private Singleton() {}
  
  public static Singleton getInstance() {
    if (instance == null) {
      instance = new Singleton();
    }
    return instance;
  }
}
```

这个例子里获取单例的唯一方法是通过`getInstance()`方法，该方法返回由所有组件共享的唯一实例。这儿有一个假设，即每次调用方代码访问单例时，都通过调用`getInstance()`方法。后续我们会讨论其他的用例，不一定每次都必须通过该方法。这种模式看起来是个捷径，通过全局的单一实例，你可以安心地共享代码。看到这里，你可能会疑惑，“这哪有什么取舍？”

我们换个上下文，看看使用这种模式是否也恰当呢。如果我们在一个多线程的环境中使用单例模式会发生什么情况？如果多个线程同时调用`getInstance()`方法，就可能产生竞争条件。这时，你的代码猝不及防地创建出了单例的两个实例。单例模式存在两个实例破坏了该模式的不变性，最终可能导致系统性的故障。为了避免发生这种情况，你需要在初始化逻辑之前，添加同步机制，代码清单如下所示：

>  代码清单 1.4 使用同步，创建线程安全的单例模式 

```java 
public class SystemComponentSingletonSynchronized {
    private static SystemComponent instance;
    
    private SystemComponentSingletonSynchronized() {}
    
    public static synchronized SystemComponent getInsntace() {
        if (instance == null) {
            instance = new SystemComponent();
        }
        
        return instance;
    }
}
```

1 同步代码块开始

同步的代码块避免了两个线程同时访问这段逻辑。初始化完成之前，仅有一个线程能进入这段逻辑，所有其他的线程都会被阻塞。咋一看，这不就是我们所期望的么。然而，如果你的代码有比较高的性能要求，采用单例模式的同时使用了多线程，程序的性能可能会有比较严重的影响。



初始化是多线程因锁竞争而等待的第一个地方。一旦完成单例的创建，接下来每次对该对象的访问还需要进行同步。单例会引起线程争用(http://mng.bz/M2nn)，进而严重影响程序性能。多线程并发访问同一个共享的对象实例时经常常发生这种问题。



同步的`getInstance()`方法一次只允许一个线程进入临界区，所有其它的线程都需要等待该锁的释放。前一个线程退出临界区后，队列中的第二个线程才能进入。这种方式的问题在于它引入的同步会严重拖慢程序执行。简言之，每次执行同步调用，都可能引入额外的开销。  



通过这个例子，我们可以得出以下结论：采用单例模式时，单线程与多线程存在着性能差异，你需要在二者间作权衡。判断最基本的出发点是应用程序的运行环境。如果你的程序不需要并发执行，或者单例不会在多个线程之间共享，那就完全不需要考虑这个问题。一旦你创建的单例需要在多个线程间共享，就需要确保它是线程安全的，从而造成潜在的性能问题。熟稔这些取舍，可以帮助你在做设计和代码实现，选择方案时理性从容。



如果你发现某个设计最初的选择弊大于利，最终可能就要变更方案。以上文的单例而言，我们可以通过两种方式改进解决方案。



第一种方法是采用双检锁（`double-checked locking`）技术。这种方式的区别在于，每次进入临界（同步）区之前，都要检查实例是否为空。如果实例为空，我们可以继续进入临界区，否则就不进入，直接返回已经存在的单例对象。下面的代码清单展示了这种锁的使用：

> 代码清单1.5 采用双检锁的单例

```java
private volatile static SystemComponent instance;

public static SystemComponent getInstance() {
    if (instance == null) {
        synchronized (ThreadSafeSingleton.class) {
            if (instance == null) {
                instance = new SystemComponent();
            }
        }
    }
    return instance;
}
```

1 如果单例对象不为空，则不需要进入临界区

采用这种模式我们可以显著降低同步以及线程竞争资源的情况。我们只会在应用启动的时候观察到发生同步，该时刻每个线程都试图初始化单例。

我们可以采用的第二种模式是“线程限定（thread confinement）”。线程限定可以将状态访问限定在特定的线程内。不过，你需要注意，这种方式从应用全局的角度而言就不再是单例模式了。每个线程都会持有一个单例对象的实例。如果你有`N`个线程，就会有`N`个实例。

这种模式下，每个线程独享一个对象实例，且这个对象仅对该线程可见。基于这样的设计，多线程之间就不再存在访问对象引起的竞争。每个对象由单一线程独享，而非多线程共享。Java语言提供了`ThreadLocal`类来达到这一效果。凭借`ThreadLocal`我们可以封装系统组件，并将其绑定到特定的线程。从代码实现的角度而言，对象存在于`ThreadLocal`实例之内，如下所示：

代码清单1.6 使用ThreadLocal进行线程限定

```java 
private static ThreadLocal<SystemComponent> threadLocalValue = new ThreadLocal<>();
public static void set() {
  threadLocalVlue.set(new SystemComponent());
}

public static void executeAction() {
  SystemComponent systemComponent = threadLocalValue.get();
}

public static SystemComponent get() {
  return threadLocalValue.get();
}
```

将`SystemComponent`与某个线程绑定的逻辑封装在`ThreadLocal`实例中。线程`A`调用`set()`方法时，`ThreadLocal`中便创建了一个新的`SystemComponent`实例。我们需要注意，此时该实例只能被线程`A`访问，这一点非常重要。如果另外一个线程，譬如`B`线程，之前没有调用过`set()`方法，试图执行`executeAction()`，它得到的就是一个空的`SystemComponent`实例，因为没有任何人为该线程执行组件的`set()`方法。只有`B`线程调用`set()`方法后，该线程独享的新实例才会被创建。



通过为`withInitial()`方法传递一个提供方(supplier方法)，我们可以简化这段逻辑。如果线程本地对象没有值，该方法就会被调用，这样我们就避免了遭遇空对象的风险。下面的代码清单展示了这一实现：

> 代码清单1.7 为线程限定添加初始值

```java 
static ThreadLocal<SystemComponent> threadLocalValue = ThreadLocal.withInitial(SystemComponent::new)
```

采用这一模式，你可以消除竞争，提升程序的性能。不过这种方案也有其弊端，程序的复杂度增加了。

**注意** 这种模式下，调用方代码访问单例时，不再需要通过`getInstance()`方法。你可以在第一次访问单例时，将其赋值给某个变量（引用）。一旦将实例赋值给变量，后续所有的调用都可以通过该引用获得单例对象，不再需要调用`getInstance()`方法。如此一来，就减少了竞争。



单例对象的实例也可以被注入到需要使用它的其它组件中。理想情况下，你的应用在一个地方创建了所有组件，并将它们注入到服务中（利用像依赖注入这样的技术）。这种情况下，你甚至根本不需要使用单例模式。你只需要创建一个需要分享的对象实例，并将它注入到所有依赖的服务中（请参考 http://mng.bz/g4dE)。当然，你也可以采用其它方式，譬如枚举类型，它的底层实现也基于单例模式。接下来让我们通过代码来验证我们的猜测。



##### 度量我们的代码 

目前为止，我们已经通过三种方式实现了线程安全的单例模式，分别是：

- 为所有的操作添加同步机制
- 使用双检锁创建单例
- 采用线程限定方式（通过`ThreadLocal`）创建单例

我们的猜想中，第一种方法应该性能最差，然而目前我们还没有任何证明数据。现在，我们将创建一个性能基准测试来验证这三种实现方式的性能差异。我们会使用性能测试工具JMH（https://openjdk.java.net/projects/code-tools/jmh/）进行性能对比测试，本书接下来的章节中也会多次使用该工具对代码的性能进行验证。



我们会创建一个执行50,000次获取`SystemComponent`(单例)对象操作的基准测试（代码请参考清单1.8）。我们会创建三个基准测试，每个基准测试使用不同的单例实现方式。为了验证竞争是如何影响程序性能的，我们会创建100个并发的线程执行这段代码。最后，结果报告中我们以毫秒呈现测试结果。

> 代码清单1.8 创建单例的基准测试

```java 
@Fork(1)
@Warmup(iterations = 1)
@Measurement(iterations = 1)
@BenchmarkMode(Mode.AverageTime)
@Threads(100)
@OutputTimeUnit(TimeUnit.MILLISECONDS)
public class BenchmarkWithSingletonVsThreadLocal {
  private static final int NUMBER_OF_ITERATIONS = 50_000;
  
  @Benchmark
  public void singletonWithSynchronization(Blackhole blackhole) {
    for (int i = 0; i < NUMBER_OF_ITERATIONS; i++) {
      blackhole.consume(SystemComponentSingletonSynchronized.getInstance());
    }
  }
  
  @Benchmark
  public void singletonWithDoubleCheckedLocking(Blackhole blackhole) {
    for (int i = 0; i < NUMBER_OF_ITERATIONS; i++) {
      blackhole.consume(SystemComponentSingletonDoubleCheckedLocking.getInstance());
    }
  }
  
  @Benchmark
  public void singletonWithThreadLocal(Blackhole blackhole) {
    for (int i = 0; i < NUMBER_OF_ITERATIONS; i++) {
      blackhole.consume(SystemComponentThreadLOcal.get());
    }
  }
}
```

> 1. 启动100个并发线程执行这段代码逻辑
> 2. 第一个基准测试采用`SystemComponentSingletonSynchronized`
> 3. 对`SystemComponentSingletonDoubleCheckedLocking`的基准测试
> 4. 获取`SystemComponentThreadLocal`的基准测试结果

执行这个测试，我们可以得到100个并发线程，完成50,000次调用的平均耗时。注意，你的实际耗时可能因环境不同有所差异，不过总体的趋势应该保持一致，就像下面这个列表所展示的。

> 列表1.9 执行不同单例实现的基准测试结果

```bash 
Benchmark                                                               Mode  Cnt    Score   Error  Units
CH01.BenchmarkSingletonVsThreadLocal.singletonWithDoubleCheckedLocking  avgt         2.629          ms/op
CH01.BenchmarkSingletonVsThreadLocal.singletonWithSynchronization       avgt       316.619          ms/op
CH01.BenchmarkSingletonVsThreadLocal.singletonWithThreadLocal           avgt         5.622          ms/op
```

查看测试结果，`singletonWithSynchronization`版本的实现的确是最慢的。完成基准测试逻辑执行的平均时间超过300毫秒。接下来的两个方案对这一行为进行了改进。`singletonWithDoubleCheckedLocking`的性能最优，只花费了大概2.6毫秒的时间，而`singletonWithThreadLocal`耗时大约5.6毫秒。据此，我们可以得出如下结论：采用线程本地化方案可以带来约50倍的性能提升，采用双检锁方案可以带来约115倍的性能提升。



通过度量我们的猜测，我们为多线程上下文选择了合适的方案。如果需要在多个方案间做选择，性能不相上下时，我们建议选择更直观的解决方案。然而，所有这一切的前提都是测试数据，没有实际的测试数据，我们很难做出客观和理性的决定。



接下来，我们将讨论涉及架构选型的设计取舍。下一节中，我们会对比微服务与单体架构，了解他们设计上的取舍。



#### 1.3 架构设计模式及其失效分析

到目前为止，我们已经了解了影响代码设计的底层编程模式以及各种选择的利弊取舍。虽然很重要，如果应用程序的上下文发生变化，你可能依旧能接受对这些底层设计做对应的修改。本书的第二部分着重讨论架构设计模式：这些模式由于横梗组成你系统的多个服务，很难做变更。我们首先要讨论的是微服务架构（http://mng.bz/enlv)，这是当今创建软件系统最通用的模式之一。



微服务架构与单体系统（单体系统创建时，所有的业务逻辑都需要在单一系统中实现）比较起来，有诸多的优势。不过，微服务架构也带来不可忽略的维护开销以及日益增加的复杂度。我们先从微服务与单体系统的最根本优势入手，了解二者的区别。



##### 1.3.1 可扩展性与弹性 

我们创建的系统需要有能力处理海量的数据，同时，它们还要能按需伸缩。如果你应用的一个节点每秒可以处理`N`个请求，流量暴增时，微服务架构允许你快速横向扩展来满足业务需要（参考图1.3）。当然，应用需要以支持容易扩展的方式编码。它也需要使用底层的组件。



举个例子，为了让你的系统有能力每秒处理2 ✖️ `N` 个请求（这里的2表示服务的数量，`N` 表示单个服务可以处理的请求数），你可以增加一个原微服务的的实例。不过，要想达到期望效果，底层的数据访问层也需要具备向上扩张的能力。



当然，扩展性也会有上限，达到上限之后，增加新节点也不一定能带来太多吞吐量的提升。性能瓶颈可能是底层组件，譬如数据库，消息队列，网络带宽等等，达到了扩展的上限。



不过，整体而言，与单体架构比起来，微服务架构的扩展性要容易得多。单体架构下，一旦某些资源达到上限，几乎不可能做快速扩展。



> 图1.3 横向扩展意味着可以通过向资源池中添加更多的机器来满足增长的业务需求

你可以通过为计算实例添加更多处理器，内存或者磁盘容量垂直扩展你的应用（通常称为纵向扩展），同样地，这种方式也存在一定限制，超过之后很难继续提升性能。举个例子，你有个单体应用部署到云端，部署时选择更强劲的云计算实例类型（更多的处理器或者更大的内存）就可以纵向扩展，提升其性能。如果能够增加更多的资源，这种方式显然是有效的。然而，云计算实例也存在资源上限，某些时候，云计算提供商可能也无法提供更强劲的机器。这种时候，横向扩展（水平扩展）所提供的灵活性优势就体现出来了。如果你的应用设计和实现时考虑了支持部署到`N`个实例，就可以通过部署更多的实例，为服务提供更高的总吞吐性能。



##### 1.3.2 开发速度

微服务架构下，工作可以比较容易地拆分到多个团队。举例而言，团队A可以创建一个单独的微服务，专注于业务功能的开发。与此同时，团队B在业务领域的另一个部分开展工作。这两个团队能互不干扰地独立工作，并可由此进行快速的迭代开发。



采用微服务架构，团队之间不需要在代码库层面进行协作。各团队可以按照自己的需求选择技术栈，快速演进开发。新成员加入团队也不需要掌握整个业务领域，只需要了解该团队负责的部分领域，可以更容易地理解系统，快速开展工作。



由于每个团队都能独立部署自己的代码库，部署流程会更健壮。所有这一切的结果是部署的频度会越来越高，风险也越来越小。即便团队偶然引入了某些缺陷，部署的影响也比较小。因为变更的内容少，调试定位潜在问题也更快。调试过程可能出现困难，譬如多个细粒度的微服务集成时报错。这种情况，我们需要进行请求跟踪，收集多个微服务之间的请求调用关系（更多内容请参考：http://mng.bz/p2w8）。



于此相反，单体架构下，多个团队成员经常要共享同一个代码库。如果你的应用代码存放在某个代码仓库中，由于应用比较复杂，多个团队同时在这个代码仓库上开展工作。这种情况下，你很可能遭遇代码冲突的情况。一旦发生这种情况，大量的开发时间都会消耗在解决这些冲突上。当然，如果产品代码能够以模块化的方式组织，一定程度上可以降低冲突的几率。然而，随着越来越多开发者的加入，产品主分支上的变更会越来越频繁，你也不得不隔三差五地做代码同步。对比单体架构和微服务架构，我们很容易发现固定业务领域的代码通常要少得多。因此，采用微服务架构出现代码冲突的概率要小得多。



单体架构的应用，部署一般不太频繁。主要的原因是每次部署都需要向主分支合并大量的功能代码（因为有更多的人在其上开展工作）。功能越多，完成这些测试所需的时间越长。同一个版本包含的功能越多，引入缺陷的概率越大。值得一提的是，通过创建稳定的持续集成（或者持续部署）流水线，这些痛点在一定程度上可以缓解。我们可以通过更频繁地运行这些流水线，更快速地构建新应用，从而让每个新版本包含更少的新功能。如果新版本代码引入了缺陷，也将更易于分析和调试。版本中包含的新功能越少，定位潜在问题的速度越快。如果我们做一个对比，同样的时间，一个发布周期中构建新应用频繁，与构建不频繁的方式做比较，前者发布最终部署到生产的特性数比后者要多得多。一个版本包含的功能越多，潜在的问题越多，也越难调试。



##### 1.3.3 微服务的复杂性

你已经了解微服务架构和单体架构对比的优势，同时你也需要了解它的短板。微服务架构是一种复杂的设计，它包含多个组成部分。如果你有合适的负载均衡器，可以很容易地实现可扩展性；负载均衡器维护了多个运行服务的列表，并为流量进行路由。底层服务可以纵向扩展，也可以收缩，这意味着服务可以按需创建和销毁。变化的跟踪是一个非常大的挑战。为了解决这一问题，我们引入了一个新的服务组册组件（如图1.4所示）。



> 图1.4 微服务架构中的服务注册



每个微服务都需要一个运行的注册客户端，该注册客户端负责向服务注册表注册该服务。一旦完成注册，负载均衡器就开始向新的实例转发流量。服务注册表会对服务实例进行健康检测，发现服务实例出现问题则执行解绑定操作。这是微服务架构所面临的诸多技术挑战之一，也导致部署变得越来越复杂和困难。



了解了方案的优点及其弊端，你还需要结合项目的实际情况，这对一个好的设计决定至关重要。如果你的项目对可扩展性没有很高的要求，同时团队规模也不大，采用单体架构可能是一个明智的选择。本书的每一章都会遵循相似的流程来评估你的设计选择：找到每种设计的优点及其短板，结合项目的上下文，解决你的困惑：什么情况下哪种设计是更优的选择。



本章中，我们向您介绍了一个设计取舍类型的例子，在什么环境下如何做取舍是本书试图回答的核心问题。通过本章，你了解了如何为你的应用选择恰当的单元测试与集成测试配比，及其底层的利弊取舍。我们也讨论了像单例模式这样久经考验的解决方案不一定是最合适的选择，我们需要综合实际的使用场景进行判断。譬如，如果你的系统是一个多线程的环境，采用单例模式可能由于线程竞争导致一定的性能问题。最后作为高层设计选择的一个例子，我们对微服务与单体架构设计模式进行了对比。



接下来的一章，我们会讨论代码重复与复用之间的取舍。我们认为代码重复不一定都是反模式或者坏事，同样，做判断时我们需要充分结合上下文。



#### 小结 

- 开发周期有限时，你也需要特别留意设计选择的后果，譬如，采用单元测试还是集成测试来保障你的代码质量。
- 久经考验的底层代码设计模式，譬如单例模式，不一定是放诸四海而皆准的“设计良药”。以单例模式为例，涉及线程安全时就会引入性能问题。所以我们做决策的时候需要结合项目的上下文，综合判断。
- 微服务架构不一定适合解决每个问题；架构设计选型时，我们需要系统地评估优缺利弊。





