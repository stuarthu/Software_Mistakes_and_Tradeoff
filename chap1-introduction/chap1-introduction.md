## 开篇导读

### 简介

>本章内容：
>
>- 设计生产系统时需考量的关键取舍
>- 选择单元测试 vs 集成测试的结果
>- 不存在“一招鲜，吃遍天”的代码与架构设计模式



无论是设计程序，还是应用程序接口抑或是系统架构，我们都需要做各种各样的决定。这些决定会影响程序的可维护性、性能、可扩展性，产生无数潜在的后果。选定某个技术方向，另一个方向的发展就会到一定限制，这种的事儿在软件研发中屡见不鲜。系统存续的时间越长，修正之前的决定，改变系统的设计越困难。本书会花费大量笔墨讨论做程序设计取舍时，如何在两个或者多个技术方案间进行选择。无论你的决定是什么，选择技术方案时清楚地了解其优缺利弊，作到"胸中有丘壑"很重要。



研发团队往往需要结合项目背景，上市时间，服务等级协议（SLA）以及其它相关因素，综合考量，才能做出一个艰难的决定。我们会毫无保留地向您展示设计这些软件系统时做的那些取舍，并与其它可选方案进行比较。希望读完本书，你会开始关注日常每天都在做的那些设计抉择。关注这些，尤其是熟稔每种选择的优缺点，可以帮助您做出清晰的抉择。



本书开篇第一部分着重讨论每位软件工程师在做`API`设计和编码时都应考虑的底层设计决定。接着讨论系统设计中更宏观的部分——架构及各组件间的数据流。讨论也会涉及采用分布式系统架构时需注意的取舍。



接下来一节我们介绍本书分析取舍所采用的方法。首先，我们着重讨论每位软件工程师都得做的判断：如何在单元测试、集成测试、端到端测试、抑或是其他类型测试之间进行平衡。实际项目中，我们的常态是研发团队要在有限的开发周期内发布软件创造价值。因此，我们需要决定在哪种测试中投入更多的时间，单元测试、集成测试、端到端测试或者其它类型的测试？我们会逐一分析每种测试类型能带来的利与弊。



接着，我们介绍久经考验的单例模式，剖析为什么上下文差异会导致该设计模式的可用性发生变化。我们会结合一个单线程和一个多线程实例对这一观点进行阐述。最后，我们会从宏观角度分析采用微服务与单体模式的利与弊。



注意，描述软件架构时，简单粗暴地用纯微服务（**only micro-service**)或者纯单体模式（**only monolithic**)都是不确切的。我们经常在实际软件项目中看到混合模式的架构：有些功能以服务的方式实现，另一些部分则以单体系统的方式存在。譬如，对某个遗留系统，它可能整体而言是单体形态，少部分功切换到了微服务架构。此外，全新项目初始时只是一个应用，如果花费大量的代价将其微服务化，往往是得不偿失的。即便你采用混合架构，也需要根据项目实际情况，选择性地运用这些原则。



我们会用统一的方式介绍每一章的内容：首先是某个特定背景下的难题是如何解决的，接着分析其它可选的解决方案。最后，补充当时做决策的上下文及最终的选择。我们会分析每种解决方案在特定上下文中的利与弊。接下来的章节会围绕这些权衡做更深入的探讨。



#### 1.1 决定的后果与模式

本书的初衷是帮大家了解程序设计时应考虑的取舍以及经验教训。谈到设计选型取舍，我有一个假设前提，即你所编写的代码已经足够健壮。优秀的代码质量是软件大厦的基础，这之后你才需要考虑架构演进的方向。



为了帮你了解本书各章通用的内容组织形式，我们首先以两个群众基础深厚的取舍为例，分别是：集成测试和单元测试，它们可能是最立竿见影的软件质量保障实践，你的代码中很可能也已经用到了它们。



最终的目标是单元测试和集成测试可以覆盖所有的代码路径。然而，这很难在实践中达成。因为项目周期是有限的，你没有那么多的时间来完成编码并进行充分的测试。因此，投资多少资源与时间到单元测试与集成测试上就变成了每个人都需要面对的问题。

##### 1.1.1 单元测试

编写测试时，你需要决定测试哪部份代码。譬如，你需要对某个简单的组件`SystemComponent`进行单元测试，它只提供了一个`public`类型的接口。其他所有的方法都是客户端无法直接访问的私有类型。该场景的代码片段如下。

**代码清单1.1 组件单元测试**

```java
public class SystemComponent {
    public int publicApiMethod() {
        return privateApiMethod();
    }
    private int privateApiMethod() {
        return complexCalculations();
    }
    private int complexCalculations(){
        // come complex logic
        return 0;
    }
}
```

这时你需要判断，要不要为`complexCalculations()`添加单元测试，是否继续保持该方法的私有成员属性。这类单元测试属于黑盒测试，只能覆盖`public`类型的API。通常，单元测试做到这种程度就已经足够。然而，极端的情况下，譬如该私有方法的逻辑特别复杂，为其添加单元测试也是物有所值的。为了做到这一点，你得降低`complexCalculation()`的访问控制。下面的代码片段展示了对应的修改。

**代码清单1.2 通过公有访问方式进行单元测试**

```java
@VisibleForTesting
public int complexCalculations() {
    // Some complex logic
    return 0;
}
```

修改方法的可见性，将其由`private`变为`public`之后，你可以为这部分之前访问级别为`private`的API编写单元测试。由于`public`方法对所有API客户端都可见，你不得不面对客户端可以直接调用该方法的窘境。你可能会说，上述代码清单中不是还有这个`@VisiableForTesting`注解么？实际情况是，这个注解只能起到"提示信息"的效果，无法强制限定调用方不使用你`API`中的公有方法。如果调用方没有留意这个注解，他们可能忽略这一点。



本节提到的两种单元测试方法并无高低优劣之分。后一种方式提供了更高的灵活性，然而，随之而来的是维护代价的增加。你可以在这二者间取一个折衷方案。譬如，将代码的包标记为`private`类型。这样一来，由于测试代码与产品代码在同一个包内，你可以直接在测试代码中调用这些方法，不再需要将方法修改成`public`了。



##### 1.1.2 单元测试与集成测试的比例

计划测试任务时，你需要考虑对你的系统而言，应该按怎样的比例分配集成测试与单元测试。通常情况下，选定一个方案会直接影响另一个的结果。此外，这些局限也受该研发项目开始的时机影响。



大多数时候我们开发功能的时间都捉襟见肘，是否要投入更多的时间在功能测试或者集成测试上需要慎重的考虑。现实场景中，我们应该充分结合单元测试和集成测试的优势，最大程度地发挥其效能，这也是为什么我们需要思考该按怎样的比例分配单元测试和集成测试。



这两种测试方法都是双刃剑，各有其利也有其弊，是你编码时不得不做的利弊权衡。单元测试的优势是速度更快，反馈时间更短，因此调试流程通常也更快。

**图1.2 集成测试 vs. 单元测试 vs. 端到端测试**

![image-20220512111738870](/Users/luminggang/Documents/workspace/DevToolPlusTips/Software-Mistakes-and-Tradeoffs-1.2.png)



由于单元测试仅在单一组件中隔离运行，无法提供系统中其它组件的信息，也无法验证该组件如何与其它组件进行交互。集成测试的重要性此时就凸显了，它可以同时测试多个组件，验证组件之间的交互效果。不过，集成测试通常不会跨多个服务或者微服务去验证某个业务功能。最后我们要介绍的是端到端测试，这种测试可以对系统进行完整的验证，由于我们需要串联起整个系统，它可能包含若干个微服务、多个数据库、消息队列等等，测试涉及的组件数目是及其庞大的。



我们要考虑的另一个纬度是创建测试所需的时间（资源）。开发单元测试相对而言比较容易，我们只需花费比较少的时间就能创建大量的单元测试用例。创建集成测试往往需要更多的时间。最消耗资源的是端到端测试，创建端到端测试的基础设施需要预备大量的投入。   



实际项目中，我们的资金和时间资源往往捉襟见肘，虽然我们秉持尽最大可能提升软件质量的愿望，也要考虑方方面面的限制。用测试覆盖代码变更可以帮我们发布更高质量的软件，减少缺陷发版遗漏；长远而言，还可以提升软件的可维护性。资源有限的情况下，我们不得不思考，该选择做什么类型的测试，以及做到什么程度。我们需要在单元测试、集成测试、端到端测试之间寻找平衡点。多维度分析特定类型测试的优势与不足，帮助我们做出更合理的判断。



有一点，需要特别强调，也特别重要，那就是添加测试会拉长开发的时间。我们希望做的测试越全面，花费的时间就越多。如果不为这些测试任务分配时间，只是死板地限定项目交付日期，很难开展有效的端到端测试工作。因此，计划为产品添加新功能时，我们也需要考虑添加对应的测试任务，而不要奢望以事后来补的方式解决问题。















