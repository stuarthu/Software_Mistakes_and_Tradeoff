## 12.1 版本管理的抽象思考

世事无常。如果你期望在生活中永远也不需要关心新的挑战或需求，那软件行业对你来说可能不是最好的选择。改变会以各种形式到来：最显而易见的可能是某块代码的需求发生了改变；但事实是几乎我们用到的所有东西（硬件，操作系统，开发者平台，编程语言，部署模型等）都会随着时间改变。所有这些改变导致了软件的复杂性和不可预测性。

版本管理希望驯服这种复杂性，沟通人和系统之间互相的预期。不同的版本规范适用于不同的需求和预期。我们会在本节看到它们的异同之处。


### 12.1.1 版本的属性

很多不同的东西都有版本：比如应用程序，库，协议，书籍，编程语言等。不同的版本规范会有不同的特性，版本可能在哪些特性上有差异，这是值得我们思考的。

**易记性**

很多版本规范设计的目标是易记性和可读性；比如说，你可以很容易记住你用的是Ubuntu 20.04，或者本书的第一版。有些版本规范很难记——最显而易见的是git哈希。我觉得自己永远记不住af257385d785f597fc8be67c84f2cf714fbe4203这样一串字符串，就算只记住af25738（git哈希的前7个字符，GitHub，Bitbucket等软件显示的缩略形式）这样的形式也很头疼，如果你需要记住这样子的多个commit（译注：git规范里用这样的哈希来作为每个commit的独特ID）的话。

**不可变性**

有时（但不是经常），我们使用的软件版本是精确且不可变更的。如果有人使用了nuget.org提供的NodaTime NuGet包的3.0.4版本，这个包的内容是永远一致的。包的提供者会阻止一个已经存在的版本被覆盖。

Git哈希本质上也是不可变更的：哈希是根据内容计算出来的，所以如果内容变了，哈希必然也要变（不考虑极小概率发生哈希碰撞的情况）。

这个属性对于软件系统的可预测性非常有用。就是对人类有点不太友好——在描述我们使用的操作系统时，你会更喜欢`Windows 10`而不是`Windows 10 build 19042.867`。不可变性和易记性并不是誓不两立的，只是两者之间的关系有点紧张，毕竟一个不可变更的版本号通常需要包含更多的细节信息。

**版本间的隐含关系**

很多版本系统尝试在一段很小的数据（版本号字符串）里传递重要的信息。我们会在12.1.3节里学习语义版本规范的时候看到明确的例子，但在其他地方也有很多例子。Visual Studio使用基于年份的营销版本：比如Visual Studio 2019就很明显比Visual Studio 2017晚发布。

有些版本之间看不出任何顺序或关系。git哈希在这里又是一个显而易见的例子。如果我给出两个git哈希，你要是不访问repo根本看不出哪个在前哪个在后，是否独立的分支，甚至看不出它们是否来自同一个repo。

最后有些版本规范看上去好像给了一些信息，但其实只会误导你。这两个版本哪个在前：Xbox还是Xbox One？Xbox 360是什么时候发布的？同样，你要是有兴趣去看一下.Net的版本历史，你会发现它也很有意思，但你不会想要使用那样的版本规范。

在设计你自己的版本规范或者选择某个已经存在的版本规范时，你需要考虑自己希望传达的是什么样的信息，以及你不希望自己的用户可能会从版本规范中推导出什么样的信息。

很多版本规范试图通过版本号提供一个重要信息，那就是版本的兼容性（或者提示该新版本跟老版本不兼容）。让我们看看这个兼容性意味着什么。


### 12.1.2 向后兼容和向前兼容

泛泛而谈，兼容性的话题一般关注的是，当代码的一个版本需要跟另一个版本一起工作时会发生什么。我们故意将这段话表述的很模糊，是因为这个概念可以有很多不同的具现方式。

`向后兼容`这个属性指的是新版本代码可以处理老版本提供的信息。`向前兼容`这个属性指的是老版本代码可以跟新版本提供的信息一起合作。

这些概念具体的例子包括：

* 作为一个语言，Java具有`向后兼容`。用Java7写的代码可以用Java17编译器编译。但它不具有`向前兼容`；Java17的某些代码可能会让Java7编译器发生编译错误。

* 库通常都具备向后兼容性；NodaTime 2.3版本依然可以跟NodaTime 2.4版本一起工作。我们会在12.2节看到关于库版本的更多细节。我们会在下一节看到，语义版本规范的补丁号提供了向前兼容性。

* web服务通常提供了向后兼容性；一个基于2021年1月10日的服务定义，由JSON编码的web请求，在2021年4月1日服务定义已经发生了变化的情况下，依然可以获得服务。只不过调用者的代码可能需要考虑如何处理响应中的未知数据（数据兼容性）。我们会在12.3节看到网络API版本的更多细节。

* 一些数据格式，比如Google Protocol Buffer（下文使用protobuf带替）和Apache Avro的设计目标就是同时具有向后兼容和向前兼容，让旧的代码可以跟新的数据存储一起工作而不会丢失来自新代码的信息。我们会在12.4节看到数据的版本管理。

有些情况下，向后和向前的说法会更令人困惑而不是更有帮助，会导致人们在开会时讨论的不是一个东西。这种时候我发现用特定的例子来描述会更有帮助一些；与其说`一个最新的客户端版本`，不如给出特定的版本数字。它不需要是一个你已经发布或正打算发布的实际版本号，可以只是一个假设。但是提供这样一个实际的例子可以避免信息的不一致。正如验收测试的`given then when`模式，这些场景会首先定义一组特定版本的特征，设想一组特定的操作，然后定义期望得到的结果。我们会在本章后续看到一些例子。


### 12.1.3 语义版本规范

语义版本规范（通常被称为SemVer）已经成为了大多数平台的库生态圈最常用的版本规范——至少理论上是这样。每个软件遵循的语义版本规范都不太一致，我们会在12.2.4看到一些好的理由。

**稳定版的规则**

遵循语义版本规范的版本号必然有三个整数部分：主版本号`major`，次版本号`minor`，以及补丁号`patch`。在图12.1中，主版本号为2，次版本号是13，补丁号则是4。

![12.1](12-1.svg)

**图12.1 语义版本规范的示例**

语义版本规范的基本规则（运用在同一个实体，比如说一个库上的时候）是

* 如果两个版本的主版本号不同，就不保证兼容性。比如说，版本2.13.4和3.0.2可能完全不兼容。

* 如果两个版本的主版本号相同，但是次版本号不同，那么较大的版本必须向后兼容较小的版本。比如说，版本2.13.4必须向后兼容2.5.3。

* 如果两个版本的主次版本号都相同，那么它们必须向前向后都兼容。比如，版本2.13.4和2.13.1必须互相兼容。

语义版本规范设计了这些规则使得它的用户在决定有必要改变版本时可以进行高效沟通：

* 如果你改变了主版本号，所有的东西都要从头来过。你需要进行严格的测试，并允许你的用户们有一段很长的升级时间。

* 如果你升级了次版本号，一切应该没什么问题。（有时候这个“应该”也不是那么靠谱，我们后面会看到。）

* 如果你升级或降级了补丁号，一切也应该没什么问题。这里要注意补丁号通常用于修复bug，但有时候你的代码可能会依赖那个有bug的行为。（比如说你可能会发现当bug修复后原来的一个解决方法现在不工作了。）这时候要降回原来的版本应该也没什么问题。

在讨论特定版本时，通常会用x或y作为版本号某个部分的占位符。比如，你可以说1.3.x必须向后兼容1.2.y。

**指代不稳定的版本**

语义版本规范也提供两种机制用来指代不稳定的版本。第一个是让主版本号等于0，用于最初的开发阶段。一般人们会预期那些主版本号为0的版本无需遵循语义版本规范；比如版本0.2.0可能跟0.1.0完全不兼容。我们甚至不需要通过改变补丁号（比如0.1.0升级到0.1.1）来维持兼容性。

第二种指代不稳定版本的方法是使用预发布标签。此时，在语义版本号后面会有一个连字符后缀带上由点号分割的标识符。

![12.2](12-2.svg)

**图12.2 语义版本规范使用预发布标签的示例**

图12.2中，版本号的主、次、补丁部分是1.4.5。后面还有一个预发布标签beta.1。一个预发布标签可以有任意多个点号分割的标识符，但通常只有1到3个。每个标识符只能包含ASCII的字母和数字或连字符。

虽然预发布版本不提供兼容性保证，不过一般来说，它是那个由主、次、补丁部分所指代的正式版本之前的一个临时版本，而该正式版本应该具备跟其它版本之间的兼容性要求。举例来说，版本1.5.0-alpha.1通常会向后兼容1.4.x。

```
选择0.x.y还是预发布标签

在过去，选择0.x.y版本号比较常见，但是后来人们意识到这样做有一个很明显的缺点；它只适用于第一个正式版（1.0.0）之前。如果你第一个稳定版的版本升级序列是0.8.0，0.9.0，1.0，那么你可能会使用1.8，1.9，2.0作为第二个主版本的升级序列。在大多数情况下，这都违背了语义版本规范的基本规则，因为升级到2.0应该意味着引入了不兼容的改变。

哪怕是第一个公开发布的版本，我都会推荐使用预发布标签。这样你就可以在第一个主版本和第二个主版本之间使用一致的发布序列（比如1.0.0-alpha.1，1.0.0-beta.1，1.0.0-beta.2，1.0.0和2.0.0-alpha.1，2.0.0-alpha.2，2.0.0-beta.1，2.0.0）。我会将0.x.y预留给非常早期的原型——或者彻底避免使用这样的版本号。
```

**构建元数据**

语义版本规范也支持将构建元数据作为一个用加号连接的后缀加入一个稳定版或预发布版的版本号里。构建元数据包含了一个用点号分割的标识符序列，和预发布标签类似。构建元数据是纯粹用来提供信息的。比如说，你的构建元数据里可能包含了一个时间戳或者一个commit哈希。

图12.3中，版本的主、次、补丁部分是1.2.3，预发布标签是beta.1，构建元数据部分则是20210321.af25738。该构建元数据是一个日期加一个commit哈希，但语义版本规范本身对其意义并没有做出任何规定。

![12.3](12-3.svg)

**图12.3 语义版本规范同时使用预发布标签和构建元数据的示例**

**版本顺序**

语义版本规范还在版本之间指定了顺序，让各种工具在可能的情况下检测版本的兼容性，并提供升级建议。通常来说，它们会以你期望的方式工作：

* 1.2.3早于2.0.0
* 1.2.3早于1.3.0
* 1.2.3早于1.2.4
* 1.3.0-alpha.5早于1.3.0-beta.1
* 1.3.0-beta.8早于1.3.0-beta.10（注意数值的比较）
* 1.3.0-beta.2早于1.3.0

完整而精确的版本顺序规则不属于本书范畴，你可以去https://semver.org查阅。在本节的最后一个部分，让我们从语义版本规范的精确指代版本移动到另一个极端：营销版本。


### 12.1.4 营销版本

语义版本规范的设计目标是用简洁的方式传递技术信息。而不是去诱惑客户买新的产品。那是营销版本的目标。本章提到营销版本的唯一原因是为了强调营销版本和语义版本规范的区别。

在很多情况下，我们都没有任何必要使用营销版本。它们通常是留给产品的，而不是库，协议，文件格式或存储数据格式。任何需要用到营销版本的地方通常也会需要提供一个更偏技术的版本号用于技术支持。这个技术版本不一定符合语义版本规范，但是通常会比营销版本更精确也更冗长。有时候技术版本甚至会跟营销版本有矛盾：你可以用2.3.1的技术版本号发布`超棒游戏`，然后用初始技术版本号1.0.0发布`超棒游戏2`。

这里主要记住它们是不同的版本规范，用于不同的目的。无论是在看别人的版本还是在设计你自己的版本规范的时候，都不要搞混这两者。

目前为止，我们还只是了解了版本管理的抽象概念。语义版本规范`主要`都是给库用的，我们会在下一节深入看看库版本管理的细节。