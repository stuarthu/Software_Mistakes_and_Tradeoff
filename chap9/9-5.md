## 9.5 选择和维护第三方依赖

为我们的代码选库总是会在代码和第三方库之间引入一些耦合。我们可以通过一个抽象层隐藏第三方库，仅暴露我们代码需要调用的方法，这需要额外的维护成本，但这是可行的。我们用的库有它们自己的生命周期。


### 9.5.1 第一印象

在我们刚开始考虑是否将一个库引入我们的应用程序时，在深入技术细节之前有很多方面需要进行速检。如果是开源库那通常是很容易做到的，但是商业库也会有很多需要回答的问题。当然，前面章节覆盖到的方面也应该深入考虑。

* *这个库的稳定性如何？* 如果它现在还没有个稳定的发行版，你能相信它会在你完成自己的代码之前发布吗？
* *有人积极维护这个库吗？* 如果这个库能够有效解决具有良好约束的问题且不需要我们定期更新，那这个库也许可以选，前提是它还没有被放弃开发。
* *这个库在社区里流行吗？* 如果它有一个活跃的生态，那我们可以很容易得到帮助。而且这也是代码质量的好指标。
* *写这个库的团队怎么样？* 如果一个库有许多人维护，特别是如果它背后有一个大公司维护并使用它，那它比那些个人开发者的兴趣项目要靠谱多了。
* *这个库有清晰的文档吗*？找找有没有API参考文档，概念文档，教程或快速启动文档。

这些都是合理的问题，它们绝对不是简单的是与否能够回答的。大企业也可能决定放弃它们开发多年的库。个人开发者有可能在几十年里尽责地维护自己的项目。有时你能够靠零散文档完成工作。这些都只是你需要有意识去思考的方面。让我们看看其他方面的更多细节，比如你会如何使用这些第三方库的代码。


### 9.5.2 复用代码的不同方式

目前为止，我们可以看到选库并不是一件轻松的任务。我们需要考虑很多因素，比如它们的配置，并发性，可扩展性，可测试性，依赖的数量，版本管理等。如果你指望库帮你干的活很复杂，且你打算使用它的各种功能，那使用第三方库的好处足以抵消这些权衡因素以及维护成本。然而， 如果你只是想要一个小功能，比如正确格式化一个字符串或者在集合上提供更多的操作方法，你可以考虑自己实现这些代码。虽然使用第三方库可能会让你的代码简单一点，但是它会给你带来所有这些维护问题和复杂度。

取决于第三方库的软件许可证，你也许可以将需要的方法复制进你的代码，给它写一些单元测试，让这段代码完全属于你。它让你能够在不引入库的所有API和方法的情况下使用生产级别的代码。如果你只是想要使用第三方库的一小部分，它可能是一个更合理的选择。当然，它也有不利之处，因为你需要负责修复它的bug。不过只要你移植的代码量很少且你完全理解这段代码，那应该没什么问题。

如果很难甚至不可能改变原始代码，你可以fork原始的库并二次开发你需要的功能。但这也会带来很多维护问题。比如，你需要持续更新自己的分支来包含原始库的bug修复。而且，经过一段时间之后，两边的代码版本可能会发生分歧，让你很难甚至不可能让它们保持一致。


### 9.5.3 锁定供应商

注意，无论一个库有多受欢迎，或者它背后的公司实力有多雄厚，我们使用的解决方案都有可能变得过时，最后被移除——可能是云服务被替换成了更好的版本，或是我们购买的商业软件背后的公司被并购了，换了个产品。而且，我们可能因为一个第三方开源库很受欢迎而选择了它。结果一段时间之后，一个新的库被开发出来，且能用更快更清晰的方式解决同样的问题，于是人们开始向新的解决方案迁移。我们使用的方案失去了它的吸引力，并在一段时间之后，进入了维护模式——不会再有新的开发了。

架构会进化，新的模式会涌现，而软件会过时。当我们开始使用一个新的库或服务时，我们应该意识到将来可能需要把它迁移到新的解决方案上。我们使用的软件组件发生迁移的概率是不一样的。如果我们知道某些库（或服务）大概率会发生迁移，我们就应该将这些库（或服务）的集成点隐藏到一个抽象层后面。这样，当切换实现的需求到来时，需要改动的点不会被传播到代码的很多地方，而是只改动我们封装的那个抽象层。

在开始使用新的库之前，我们要观察它如何影响我们的应用程序和架构。集成需要的侵入式代码越多，将来改变供应商就越难。在真实世界中，很难甚至不可能把所有的库和服务的集成点都隐藏到抽象层里。锁定供应商后要想再换也会很难。但我们可以通过选择不需要跟应用程序紧耦合的库来让风险最小化。


### 9.5.4 软件许可

在决定使用另一个库里的代码时，你需要看一下它的软件许可证。比如，假设你看中了一个具备GNU通用公共许可证的库，打算把它的一部分代码用在你自己的项目里，你就需要公开你项目的源代码。对于那些不想暴露代码的内部项目来说，这是一个阻断器。选择软件许可是很复杂的决定，出错后的代价可能很高。所以，如果你对此有疑问，我建议你咨询一个能够给你提供正确指引的法律部门。


### 9.5.5 库和框架

通常，当我们刚开始使用一个库时，对它进行抽象不需要付出很高代价。比如，所有访问HTTP服务的库的调用可以被隐藏到我们的客户服务类里。接下来，应用程序和HTTP库之间所有的互动都可以通过这个服务类来进行，而不需要直接使用HTTP库。然而，我们要小心别把这个库里的任何东西泄露出去，包括异常（如我们在第3章学到的）和配置（如我们在第6章学到的）。如果我们做了隐藏，将来换实现就会比较简单。换一个库不会需要很高的成本。我们也可以决定自己实现这块逻辑并移除对这个库的依赖。

使用框架的情况就完全两样了。框架会给我们应用程序的代码带来很大的影响。有些框架是侵入式的，需要我们在应用程序中使用它们的结构。只要看一下我们代码里引用的包就可以看到。引用的框架包越多，它跟我们应用程序的耦合就越紧。在我们应用程序的生命周期里换框架的难度要比换库高多了。基于这个事实，我们应该在选框架的时候进行更仔细和彻底的调查（相比于选库）。


### 9.5.6 安全和更新

我们要关注的最后也是最重要的方面是第三方库对我们软件的安全影响。我们知道所有的软件都会有bug。这些bug不仅影响我们应用程序的正确性和性能，也会影响它的整体安全性。所以我们要在部署应用程序的新版本之前进行安全性测试。我们的代码的自动安全扫描能找到一些问题，但别忘了我们用的库也变成了我们的代码。

每一个第三方依赖都会升级并引入安全漏洞。当人们在某个第三方库里找到一个新的安全漏洞，这个库的作者应该以最高优先级来处理它。通常它会在被发现后不久导致一个新的版本发布。一旦它被修复，我们就要尽快更新这个库。我们拖的越久，潜在的攻击者能够利用那个漏洞的时间就越长。

我们如何能够发现一个第三方依赖存在安全问题？我们可以去一些关注安全漏洞的网站（比如https://www.cvedetails.com/）搜索我们用的库。这些网站包含了很多产品和库在安全方面的更新。但是，手动检查网站很繁琐也很花时间。幸运的是我们可以进行自动安全检查，检索所有的第三方库并在发现问题时通知我们。有些工具（比如https://dependabot.com/）甚至可以自动更新版本并向我们的代码库提交一个改动（比如通过Git提交一个pull request）。

库的安全更新是最重要的关注点，但我们也要兼顾一下其他类型的更新。如果有一个主版本升级，你可能需要调查它改动了哪些地方并考虑在将来进行升级。尤其是当老版本的支持周期有限的时候。

如果库正确遵循了语义化版本控制规范，次版本升级就会比较简单，而且你可能会发现新的功能可以简化你自己的某些代码。另一个值得你注意的是新版本里修复了哪些bug。有时你会意识到你的应用程序正在受到某个bug的影响而你自己此前都没发现。


### 9.5.7 选择第三方库的检查列表

如果你需要使用第三方库的大多数功能（或者复制代码的方案不可行），下面的检查列表列出了本章提到的所有需要验证的内容。这个检查列表可以减少很多你的应用程序将来可能遇到的问题。

* *可配置性和默认配置*——我们是否可以提供（并覆盖）所有的关键设置？
* *并发模型，可扩展性和性能*——如果我们的应用程序是异步的，它是否也提供了一个异步API？
* *分布式环境*——它是否可以在一个分布式环境（多节点）下安全运行？
* *可靠性调查*——我们在选的是框架还是库？如果是框架，我们需要进行更彻底的调查。
* *用单元测试和集成测试验证我们对库的假设*——为使用这个库的代码写单元测试有多难？这个库是否提供了它自己的测试工具包？
* *依赖*——这个库有哪些依赖？它是自包含的独立包吗？还是它会下载很多外部依赖，影响到了我们应用程序的大小和复杂性？
* *版本控制*——这个库遵循语义化版本控制规范吗？它的升级是向下兼容的吗？
* *可维护性*——它现在流行吗？是否有人积极维护它？
* *集成*——集成这个库需要写很多侵入式代码吗？如果我们锁定单一供应商，风险有多大？
* *软件许可*——这个第三方库的软件许可证是否允许你以自己的方式使用它？
* *安全和更新*——它是否频繁更新它的下游组件来弥补它们的安全漏洞？


## 总结

* 我们用的大多数库都需要一些配置。注意那些可能影响你生产环境代码的默认配置。
* 基于惯例的配置可以简化原型和开发阶段，但会在生产环境流量下出现问题。
* 我们应该使用提供并发模型的第三方库。这让我们可以创建具有良好性能的应用程序。
* Java中可以很容易地在同步环境中使用异步API，用同步抽象层封装异步API的操作也很简单。而创建异步抽象层封装同步API则会给我们的应用程序增加大量复杂度。
* 如果我们想要在将来换成异步模式，选择同步库会限制我们的可扩展性
* 第三方库的可扩展性可能在单节点和N节点的分布式环境下有很大区别。我们应该在换库代价还不大的时候就及时验证我们对库的可扩展性模型的假设。
* 我们应该用测试验证我们对不属于我们的代码的假设。
* 第三方库的可测试性是必须的。这也表明了这个库的代码质量。
* 库自带的单元测试和集成测试工具包让我们可以更快更简单地测试代码。
* 每一个第三方依赖都会带来自己的依赖。我们应该在引入这些代码前意识到它们并检查它们。
* 我们应用程序的大小在容器环境和无服务环境下很关键。应用程序越小，部署越快。
* 我们应该持续更新第三方库来修复这些库所有的bug，安全和性能问题。我们选的库应该使用语义化版本控制规范。它会简化更新流程。
* 语义化版本控制规范给我们提供了很多关于这个库的生命周期和开发活动的信息。如果主版本发生了变化，我们可以知道升级将不会是一个简单的事情。但如果只是次版本或修正版本发生了变化，升级就很简单。